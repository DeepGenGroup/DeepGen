 === start mlir =====
module {
  func.func public @broadcast(%arg0: memref<32x16xf32, 1>) {
    affine.parallel (%arg1) = (0) to (16) {
      affine.parallel (%arg2) = (0) to (32) {
        %c4127_i32 = arith.constant 4127 : i32
        %c0_i32 = arith.constant 0 : i32
        %0 = affine.load %arg0[%arg1 + (%arg2 floordiv 16) * 16, %arg2 mod 16] : memref<32x16xf32, 1>
        %shuffleResult, %valid = gpu.shuffle  idx %0, %c0_i32, %c4127_i32 : f32
        affine.store %shuffleResult, %arg0[%arg1 + (%arg2 floordiv 16) * 16, %arg2 mod 16] : memref<32x16xf32, 1>
      } {gpu.index = "threadIdx"}
    } {gpu.index = "blockIdx"}
    return
  }
}
 === after transforms =====
module attributes {kcg.externlibs = {library_0 = "/home/xiebaokang/projects/mlir/amendDeepGen/third_party/cuda/lib/libdevice.10.bc"}} {
  func.func public @broadcast(%arg0: memref<32x16xf32, 1>) attributes {func.block.dim = array<i32: 32>, func.grid.dim = array<i32: 16>} {
    %c0_i32 = arith.constant 0 : i32
    %c4127_i32 = arith.constant 4127 : i32
    %block_id_x = gpu.block_id  x
    %thread_id_x = gpu.thread_id  x
    %0 = affine.load %arg0[%block_id_x + (%thread_id_x floordiv 16) * 16, %thread_id_x mod 16] : memref<32x16xf32, 1>
    %shuffleResult, %valid = gpu.shuffle  idx %0, %c0_i32, %c4127_i32 : f32
    affine.store %shuffleResult, %arg0[%block_id_x + (%thread_id_x floordiv 16) * 16, %thread_id_x mod 16] : memref<32x16xf32, 1>
    return
  }
}
 === after firstLowering =====
module attributes {kcg.externlibs = {library_0 = "/home/xiebaokang/projects/mlir/amendDeepGen/third_party/cuda/lib/libdevice.10.bc"}} {
  func.func public @broadcast(%arg0: memref<32x16xf32, 1>) attributes {func.block.dim = array<i32: 32>, func.grid.dim = array<i32: 16>} {
    %c-1 = arith.constant -1 : index
    %c0 = arith.constant 0 : index
    %c16 = arith.constant 16 : index
    %c0_i32 = arith.constant 0 : i32
    %c4127_i32 = arith.constant 4127 : i32
    %block_id_x = gpu.block_id  x
    %thread_id_x = gpu.thread_id  x
    %0 = arith.cmpi slt, %thread_id_x, %c0 : index
    %1 = arith.subi %c-1, %thread_id_x : index
    %2 = arith.select %0, %1, %thread_id_x : index
    %3 = arith.divsi %2, %c16 : index
    %4 = arith.subi %c-1, %3 : index
    %5 = arith.select %0, %4, %3 : index
    %6 = arith.muli %5, %c16 overflow<nsw> : index
    %7 = arith.addi %block_id_x, %6 : index
    %8 = arith.remsi %thread_id_x, %c16 : index
    %9 = arith.cmpi slt, %8, %c0 : index
    %10 = arith.addi %8, %c16 : index
    %11 = arith.select %9, %10, %8 : index
    %12 = memref.load %arg0[%7, %11] : memref<32x16xf32, 1>
    %shuffleResult, %valid = gpu.shuffle  idx %12, %c0_i32, %c4127_i32 : f32
    memref.store %shuffleResult, %arg0[%7, %11] : memref<32x16xf32, 1>
    return
  }
}
 === after secondLowering =====
module attributes {kcg.externlibs = {library_0 = "/home/xiebaokang/projects/mlir/amendDeepGen/third_party/cuda/lib/libdevice.10.bc"}} {
  llvm.func @broadcast(%arg0: !llvm.ptr<1>) attributes {func.block.dim = array<i32: 32>, func.grid.dim = array<i32: 16>, nvvm.kernel = true} {
    %0 = llvm.mlir.constant(32 : i32) : i32
    %1 = llvm.mlir.constant(-1 : i32) : i32
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.mlir.constant(4127 : i32) : i32
    %4 = llvm.mlir.constant(0 : i32) : i32
    %5 = llvm.mlir.constant(-1 : index) : i32
    %6 = llvm.mlir.constant(16 : index) : i32
    %7 = llvm.mlir.constant(0 : index) : i32
    %8 = nvvm.read.ptx.sreg.ctaid.x : i32
    %9 = nvvm.read.ptx.sreg.tid.x : i32
    %10 = llvm.icmp "slt" %9, %7 : i32
    %11 = llvm.sub %5, %9 : i32
    %12 = llvm.select %10, %11, %9 : i1, i32
    %13 = llvm.sdiv %12, %6 : i32
    %14 = llvm.sub %5, %13 : i32
    %15 = llvm.select %10, %14, %13 : i1, i32
    %16 = llvm.mul %15, %6 overflow<nsw> : i32
    %17 = llvm.add %8, %16 : i32
    %18 = llvm.srem %9, %6 : i32
    %19 = llvm.icmp "slt" %18, %7 : i32
    %20 = llvm.add %18, %6 : i32
    %21 = llvm.select %19, %20, %18 : i1, i32
    %22 = llvm.mul %17, %6 : i32
    %23 = llvm.add %22, %21 : i32
    %24 = llvm.getelementptr %arg0[%23] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %25 = llvm.load %24 : !llvm.ptr<1> -> f32
    %26 = llvm.sub %0, %3 : i32     // 32 - 16 = 16
    %27 = llvm.lshr %1, %26 : i32   // -1 >> 16 = -1
    %28 = llvm.sub %3, %2 : i32     // 16 - 1 = 15
    %29 = nvvm.shfl.sync  idx %27, %25, %4, %28 : f32 -> f32  // thread_mask / val / offset / mask_and_clamp
    llvm.store %29, %24 : f32, !llvm.ptr<1>
    llvm.return
  }
}
bin path: /tmp/compile-ptx-src-e4434d.cubin
==== ptx code: 
//
// Generated by LLVM NVPTX Back-End
//

.version 8.0
.target sm_80
.address_size 64

	// .globl	broadcast

.visible .entry broadcast(
	.param .u64 .ptr .global .align 1 broadcast_param_0
)
{
	.reg .b32 	%r<16>;
	.reg .f32 	%f<3>;
	.reg .b64 	%rd<4>;

	ld.param.u64 	%rd1, [broadcast_param_0];
	mov.u32 	%r1, %ctaid.x;
	mov.u32 	%r2, %tid.x;
	shr.s32 	%r3, %r2, 31;
	xor.b32  	%r4, %r3, %r2;
	shr.s32 	%r5, %r4, 31;
	shr.u32 	%r6, %r5, 28;
	add.s32 	%r7, %r4, %r6;
	shr.u32 	%r8, %r7, 4;
	xor.b32  	%r9, %r8, %r3;
	and.b32  	%r10, %r2, 15;
	shl.b32 	%r11, %r9, 8;
	shl.b32 	%r12, %r1, 4;
	add.s32 	%r13, %r11, %r12;
	or.b32  	%r14, %r13, %r10;
	mul.wide.s32 	%rd2, %r14, 4;
	add.s64 	%rd3, %rd1, %rd2;
	ld.global.f32 	%f1, [%rd3];
	shfl.sync.idx.b32	%f2, %f1, 0, 4126, %r15;
	st.global.f32 	[%rd3], %f2;
	ret;

}

